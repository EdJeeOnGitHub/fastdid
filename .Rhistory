cohort_name <- "G"
balance_name <- "x"
#event_panel <- copy(dt)
event_panel <- dt
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
balanced_panel = TRUE,
control_group = "both")
source("source/create_event_data.R")
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1, stratify = FALSE)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
#event_panel <- copy(dt)
event_panel <- dt
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
balanced_panel = TRUE,
control_group = "both")
traceback()
# eventcode
#Treated households:
create_event_data<-function(maindata,
timevar,
unitvar,
cohortvar, #period when the particular event of interest arises
control_group, #options: "both", "never", and "later"
base_time = -1,
anycohortvar = NULL, #period when ANY kind of event arises, used to find control cohorts
#covaraites
covariate_base_stratify=NULL, #vector of variable names, treatment effects are stratified by their joint unique values.
covariate_base_balance=NULL, #vector of variable names to include in finding exact matches for treated units
covariate_base_balance_linear=NULL, #vector of variable names to include linearly in propensity score estimator
covariate_base_balance_linear_subset=NULL, #vector of variable names within which the linear propensity score regression will be estimated
covariate_base_support=NULL, #vector of variable names on which to impose common support across treated and control units
#checks and control
balanced_panel = TRUE, #If TRUE, enforce the dataset into a balanced panel
lower_event_time = -Inf, #Earliest period (relative to treatment time) for which to estimate effects
upper_event_time = Inf, #Latest period (relative to treatment time) for which to estimate effects
min_control_gap = NULL, #controls must be treated at least this many years away from matched treated units
max_control_gap = NULL, #controls must be treated no more than this many years away from matched treated units
treat_criteria = NULL, #replacement of onsetagevar, provide a character col that must == TRUE for the treated
base_restrict = NULL, #a single var, restricting to households for which var == 1 in base period,
base_restrict_treated = NULL, #a single var, restricting TREATED GUYS to households for which var == 1 in base period,
check_not_treated = FALSE, #If TRUE, only allows controls to be used for cohort o if they are observed in the dataset to be untreated in year o.
stratify_by_cohort= FALSE,
#legacy/advanced
instrument=NA,
covs_instrument_base_balance=NA, #Balance these characteristics jointly across BOTH treatment and instrument status.
instrument_exposure="full",
stratify_balance_val = NA #Set to TRUE to balance each strata on covariates to look like the overall treated sample, Set to a value of "stratify" to balance all other strata to look like the given one.
)
{
# name change ----------------------------------
if(is.null(anycohortvar)){
maindata[,anycohortvar:=get(cohortvar)]
anycohortvar<-"anycohortvar"
}
setnames(maindata,c(timevar,unitvar,cohortvar,anycohortvar),c("time","id","cohort","anycohort"))
if(!is.null(base_restrict)) setnames(maindata,base_restrict,"base_restrict")
if(!is.null(base_restrict_treated)) setnames(maindata,base_restrict_treated,"base_restrict_treated")
if(any(is.na(maindata$cohort))) stop("cohort variable should not be missing (it can be infinite instead)")
if(any(is.na(maindata$anycohort))) stop("anycohort variable should not be missing (it can be infinite instead)")
if(is.null(covariate_base_balance_linear_subset)) covariate_base_balance_linear_subset <- covariate_base_balance
# validation -----------------------------------
if(lower_event_time > base_time) stop("lower_event_time must lie below base_time")
if(!is.data.table(maindata)) stop("rawdata must be a data.table")
if(!all(is.na(stratify_balance_val)) & all(covariate_base_stratify == 1)) stop("It makes no sense to specify stratify_balance_val without specifying covariate_base_stratify")
if(!instrument_exposure %in% c("full","partial","all","base")) stop("instrument_exposure, must be set to either full, partial, all, or base")
if(balanced_panel){
#check if any is dup
if(anyDuplicated(maindata[, .(id, time)])){
dup <- duplicated(maindata[,.(id, time)])
warning(nrow(dup_id), " units is observed more than once in some periods, enforcing balanced panel by dropping them")
maindata <- maindata[!id %fin% dup]
}
#check if any is missing
id_count <- maindata[, .(count = .N), by = id]
time_period <- maindata[, uniqueN(time)]
if(any(id_count[, count < time_period])){
mis_id <- id_count[count < time_period]
warning(nrow(mis_id), " units is missing in some periods, enforcing balanced panel by dropping them")
maindata <- maindata[!id %fin% mis_id$id]
}
#can't just check count = period because one may be missing in one period and observed multiple time in another
}
# stacking for cohort -----------------------------------------------------------------
treatdata<-copy(maindata[!is.infinite(cohort) & !is.infinite(anycohort) ,])
if(!is.null(treat_criteria)){
treatdata <- treatdata[get(treat_criteria == TRUE)]
}
treatdata[,treated:=1]
treatdata[,event_time:=time-cohort]
treatdata<-treatdata[event_time >= lower_event_time & event_time <= upper_event_time,]
treatdata[,treatgroup:="treated"]
#stacking control cohorts.
#I assume people who never suffer the event have a value cohort = Inf
control_list <- list()
for(o in unique(treatdata$cohort)){
#find the relevant control group
if(control_group=="both") {
controlcohort <- maindata[(anycohort > o | is.infinite(anycohort)) ,]
controlcohort[is.infinite(anycohort),treatgroup:="never-treated"]
controlcohort[!is.infinite(anycohort),treatgroup:="later-treated"]
}
if(control_group=="later"){
controlcohort <- maindata[(anycohort > o & !is.infinite(anycohort)) ,]
controlcohort[,treatgroup:="later-treated"]
}
if(control_group=="never") {
controlcohort <- maindata[is.infinite(anycohort) ,]
controlcohort[,treatgroup:="never-treated"]
}
if (!is.null(max_control_gap)) controlcohort <- controlcohort[anycohort - o <=  max_control_gap,]
if (!is.null(min_control_gap))  controlcohort <- controlcohort[anycohort - o >=  min_control_gap,]
controlcohort[,cohort := o]
controlcohort[,event_time := time - cohort]
#Make sure people in the control cohort are actually observed in that period
#(to verify they don't belong to the cohort)
if(check_not_treated == TRUE){
controlcohort[ ,obscohort := max(time == o),by=id]
controlcohort<-controlcohort[obscohort==1,]
controlcohort[,obscohort:=NULL]
}
#drop someone from the control cohort when they get treated:
controlcohort<-controlcohort[anycohort - cohort > event_time ,]
control_list <- c(control_list, list(controlcohort))
}
rm(controlcohort)
controldata<-rbindlist(control_list)
gc()
controldata[,treated:=0]
controldata<-controldata[event_time >= lower_event_time & event_time <= upper_event_time,]
# covariate to factor -----------------------------------------------------------
#turn covariates to factor
covariates <- c(covariate_base_stratify, covariate_base_balance, covariate_base_support)
for(out in covariates){
treatdata[,eval(out) := min(get(out) + 9e9 *(event_time != base_time)), by=.(id,cohort)]
treatdata[get(out) >= 9e9,eval(out) := NA, ]
treatdata[,eval(out) := qF(get(out))]
controldata[,eval(out) := min(get(out) + 9e9 *(event_time != base_time)), by=.(id,cohort)]
controldata[get(out) >= 9e9,eval(out) := NA, ]
controldata[,eval(out) := qF(get(out))]
}
#turn covariates interaction to factors
if(!is.null(covariate_base_stratify)){
stratifyvars <- ifelse(stratify_by_cohort, c(covariate_base_stratify, "cohort"))
} else {stratifyvars <- covariate_base_stratify}
for(covariate_type in c("stratify", "balancevars", "balancevars_linear_subset", "supportvars")){
cov_vars <- switch(covariate_type,
stratify = stratifyvars,
balancevars = covariate_base_balance,
balancevars_linear_subset = covariate_base_balance_linear_subset,
supportvars = covariate_base_support)
if(is.character(cov_vars)){
treatdata[,(covariate_type) :=  do.call(finteraction, treatdata[, cov_vars, with = FALSE])]
controldata[,(covariate_type) :=  do.call(finteraction, controldata[, cov_vars, with = FALSE])]
} else {
treatdata[,(covariate_type) := factor(1,levels=c(1,"OMIT"))]
controldata[,(covariate_type) := factor(1,levels=c(1,"OMIT"))]
}
}
# checking observation -----------------------------------------------------------------
#check if any unit is observed more then once in the base period
if(!balanced_panel){
#only needed when panel is not already balanced
treatdata[,obsbase:=sum(event_time==base_time),by=.(id,cohort)]
controldata[,obsbase:=sum(event_time==base_time),by=.(id,cohort)]
if(max(treatdata$obsbase)>1) stop("Error: some treated units are observed more than once in the reference period")
if(max(controldata$obsbase)>1) stop("Error: some control units are observed more than once in the reference period")
treatdata <- treatdata[obsbase==1,]
controldata <- controldata[obsbase==1,]
treatdata[,obsbase := NULL]
controldata[,obsbase := NULL]
}
#check base-restrict
if(!is.null(base_restrict)){
controldata[,base_restrict := max(base_restrict * (event_time == base_time), na.rm=TRUE),by=.(id, cohort)]
controldata <- controldata[base_restrict == 1,]
treatdata[,base_restrict := max(base_restrict * (event_time == base_time), na.rm=TRUE),by=.(id, cohort)]
treatdata <- treatdata[base_restrict == 1,]
}
if(!is.null(base_restrict_treated)){
treatdata[,base_restrict_treated := max(base_restrict_treated * (event_time == base_time), na.rm=TRUE),by=.(id, cohort)]
treatdata <- treatdata[base_restrict_treated == 1,]
}
#check common support
if(!is.null(covariate_base_balance_linear)){
#common support checking is only needed when there is linear regression - interpolation and extrapolation
#o.w. a propensity score within 0,1 means it has common support
treatdata[,temp:=finteraction(balancevars,supportvars,stratify,event_time,cohort)]
controldata[,temp:=finteraction(balancevars,supportvars,stratify,event_time,cohort)]
commonvals<-intersect(unique(treatdata$temp),unique(controldata$temp))
treatdata<-treatdata[temp%in%commonvals,]
controldata<-controldata[temp%in%commonvals,]
treatdata[,temp:=NULL]
controldata[,temp:=NULL]
rm(commonvals)
gc()
}
# stacking for event_time ----------------------------------------------------------------
#if is balanced panel, after knowing its max and min, can be sure it is observed when in the middle
controldata[, `:=`(min_event_time = min(event_time),
max_event_time = max(event_time)), by = .(id, cohort)]
treatdata[, `:=`(min_event_time = min(event_time),
max_event_time = max(event_time)), by = .(id, cohort)]
event_times<-treatdata[,funique(event_time)]
data_list <- list()
for(t in event_times){
pair_treat_data <- treatdata[t >= min_event_time & t <= max_event_time & (event_time == t | event_time == base_time)]
pair_control_data <- controldata[t >= min_event_time & t <= max_event_time & (event_time == t | event_time == base_time)]
pair_treat_data[,time_pair := t]
pair_control_data[,time_pair := t]
data_list<-c(data_list, list(pair_treat_data), list(pair_control_data))
}
eventdata <- rbindlist(data_list,use.names=TRUE)
# estimating ipw ----------------------------------------------------------------------------------
if(is.null(eventdata)) {stop("eventdata is empty!")}
eventdata[,anycohort:=NULL]
rm(treatdata)
rm(controldata)
gc()
eventdata[,post:=event_time >= 0]
#turn the cols into factors
factor_cols <- c("id", "treatgroup", "cohort", "time_pair", "time", "treated")
for(col in factor_cols){
eventdata[, (col) := qF(get(col))]
}
#keep a numeric version for later comparisons
eventdata[, event_time_fact := qF(event_time)]
if(is.null(covariate_base_stratify)){
eventdata[, stratify := 1]
}
if(is.null(covariate_base_balance)){
eventdata[, balance := 1]
}
#construct the call
if(is.null(covariate_base_balance_linear)){
call <- "treated ~ 1 | finteraction(cohort,time_pair,event_time_fact,stratify,balancevars)"
} else {
call <- paste0("treated ~",paste0(covariate_base_balance_linear,collapse="+",
sep="finteraction(cohort,event_time_fact,time_pair,stratify,balancevars_linear_subset,)"),
"| finteraction(cohort,event_time_fact,time_pair,stratify,balancevars)")
}
#estimate propensity score
#in a specific cohort-time_pair estimation, propensity to get treated at event_time, given stratify and balance
eventdata[,pval:= feols(as.formula(call), data = eventdata, lean = FALSE)$fitted.values]
#only keep propensity score between 0,1 is equivalent to checking common support
eventdata <- eventdata[pval < 1 & pval > 0]
eventdata[,pweight := ifelse(treated == 1, 1, pval/(1-pval))]
eventdata[,pval:=NULL]
#  deal with extensions ----------------------------------------------
if(!is.na(instrument)){
eventdata <- eventdata |> process_iv(instrument, instrument_exposure, covs_instrument_base_balance, saturate)
}
if(!is.na(stratify_balance_val)){
eventdata <- eventdata |> process_stratify(stratify_balance_val)
}
eventdata[,treated:=qF(treated)]
# construct_event_variables --------------------------------------------
if(!is.na(instrument)){
eventdata <- construct_event_variables_iv(eventdata)
}
return(eventdata)
}
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1, stratify = FALSE)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
#event_panel <- copy(dt)
event_panel <- dt
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
balanced_panel = TRUE,
control_group = "both")
traceback()
source("source/create_event_data.R")
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
balanced_panel = TRUE,
control_group = "both")
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1, stratify = FALSE)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
#event_panel <- copy(dt)
event_panel <- dt
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
balanced_panel = TRUE,
control_group = "both")
profvis(
event_est <- get_result_dynamic(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE)
)
source("source/get_event_result.R")
source("source/create_event_data.R")
profvis(
event_est <- get_result_dynamic(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE)
)
profvis(
event_est <- get_event_result(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE, result_type = "dynamic")
)
rm(list = ls())
gc()
library(profvis)
setwd("~/GitHub/EventStudyCode")
# load event code ---------------------------------------------------------------------
source("sim_did.R")
source("source/setup.R")
source("source/get_event_result.R")
source("source/create_event_data.R")
rm(list = ls())
gc()
library(profvis)
setwd("~/GitHub/EventStudyCode")
# load event code ---------------------------------------------------------------------
source("sim_did.R")
source("source/setup.R")
source("source/get_event_result.R")
source("source/create_event_data.R")
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
stratify_name <- "s"
#event_panel <- copy(dt)
event_panel <- dt
profvis({
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
covariate_base_stratify = stratify_name,
balanced_panel = TRUE,
control_group = "both")
})
profvis(
event_est <- get_event_result(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE, result_type = "dynamic")
)
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
stratify_name <- "s"
#event_panel <- copy(dt)
event_panel <- dt
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
covariate_base_stratify = stratify_name,
balanced_panel = TRUE,
control_group = "both")
source("source/create_event_data.R")
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
stratify_name <- "s"
#event_panel <- copy(dt)
event_panel <- dt
profvis({
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
covariate_base_stratify = stratify_name,
balanced_panel = TRUE,
control_group = "both")
})
profvis(
event_est <- get_event_result(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE, result_type = "dynamic")
)
rm(list = ls())
gc()
library(profvis)
setwd("~/GitHub/EventStudyCode")
# load event code ---------------------------------------------------------------------
source("sim_did.R")
source("source/setup.R")
source("source/get_event_result.R")
source("source/create_event_data.R")
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
stratify_name <- "s"
#event_panel <- copy(dt)
event_panel <- dt
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
covariate_base_stratify = stratify_name,
balanced_panel = TRUE,
control_group = "both")
head(event_panel)
is.null("hi", NULL)
is.null(c("hi", NULL))
head(event_panel)
rm(list = ls())
gc()
library(profvis)
setwd("~/GitHub/EventStudyCode")
# load event code ---------------------------------------------------------------------
source("sim_did.R")
source("source/setup.R")
source("source/get_event_result.R")
source("source/create_event_data.R")
simdt <- sim_did(100000, 10, cov = "int", hetero = "dynamic", balanced = FALSE, second_outcome = FALSE, seed = 1)
dt <- simdt$dt
min_time <- -Inf
max_time <- Inf
y_name <- c("y")
t_name <- "time"
unit_name <- "unit"
cohort_name <- "G"
balance_name <- "x"
stratify_name <- "s"
#event_panel <- copy(dt)
event_panel <- dt
profvis({
event_panel <- event_panel %>% create_event_data(timevar = t_name, unitvar = unit_name,
cohortvar = cohort_name,
covariate_base_balance = balance_name,
covariate_base_stratify = stratify_name,
balanced_panel = TRUE,
control_group = "both")
})
profvis(
event_est <- get_event_result(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE, result_type = "dynamic")
)
# estimation ---------------------------------------
get_event_result<-function(eventdata,
variable,
result_type,
covariate = NULL,
clustervar="id",
weights="pweight",
base_time = -1,
trends=FALSE,
mem.clean = TRUE,
separate_stratify = TRUE)
{
if(is.null(covariate) & result_type == "covariates"){stop("please provide covariate when getting covariates result")}
eventdata |> validate_eventdata(variable)
eventdata <- eventdata[!is.na(get(weights))]
eventdata <- eventdata |> construct_event_variable(result_type, variable, covariate, base_time)
call <- get_estimate_call(result_type, variable, trends, covariate)
if(eventdata[, uniqueN(stratify)] > 1 & separate_stratify){
dt <- data.table()
for(stratify_type in eventdata[, unique(stratify)]){
strat_eventdata <- eventdata[stratify == stratify_type]
strat_results<-feols(as.formula(call),
data = strat_eventdata,
weights= strat_eventdata[,get(weights)],
cluster=clustervar, lean = TRUE, mem.clean = mem.clean)
strat_dt <- parse_event_result(strat_results, variable, result_type)
strat_dt[, stratify := stratify_type]
dt <- rbind(dt, strat_dt)
}
} else {
results<-feols(as.formula(call),
data = eventdata,
weights= eventdata[,get(weights)],
cluster=clustervar, lean = TRUE, mem.clean = mem.clean)
dt <- parse_event_result(results, variable, result_type)
}
return(dt)
}
profvis(
event_est <- get_event_result(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE, result_type = "dynamic")
)
profvis(
event_est <- get_event_result(event_panel, variable = y_name, trends = FALSE, mem.clean = FALSE, result_type = "dynamic", separate_stratify = FALSE)
)
